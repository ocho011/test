"""
Event types and models for the trading bot's event-driven architecture.

This module defines all event types used throughout the system using
pydantic for validation and serialization/deserialization.
"""

from abc import ABC
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, Literal, Optional, Union
from uuid import UUID, uuid4

from pydantic import BaseModel, Field, validator


class EventType(Enum):
    """Enumeration of all event types in the system."""

    MARKET_DATA = "market_data"
    SIGNAL = "signal"
    ORDER = "order"
    RISK = "risk"


class EventPriority(Enum):
    """Event priority levels for processing order."""

    LOW = 1
    NORMAL = 2
    HIGH = 3
    CRITICAL = 4


class BaseEvent(BaseModel, ABC):
    """
    Base class for all events in the trading bot system.

    Provides common event metadata including timestamps, priority,
    and unique identification.
    """

    event_id: UUID = Field(default_factory=uuid4, description="Unique event identifier")
    event_type: EventType = Field(..., description="Type of event")
    timestamp: datetime = Field(
        default_factory=datetime.utcnow, description="Event creation timestamp"
    )
    priority: EventPriority = Field(
        default=EventPriority.NORMAL, description="Event processing priority"
    )
    source: str = Field(..., description="Component that generated this event")
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional event metadata"
    )

    class Config:
        json_encoders = {
            datetime: lambda dt: dt.isoformat(),
            Decimal: lambda d: str(d),
            UUID: lambda u: str(u),
        }


class MarketDataEvent(BaseEvent):
    """
    Market data event containing price and volume information.

    Used for real-time and historical market data distribution
    throughout the trading system.
    """

    event_type: Literal[EventType.MARKET_DATA] = Field(default=EventType.MARKET_DATA)
    symbol: str = Field(..., description="Trading symbol (e.g., BTCUSDT)")
    price: Decimal = Field(..., description="Current price")
    volume: Decimal = Field(..., description="Volume in base currency")
    bid: Optional[Decimal] = Field(None, description="Best bid price")
    ask: Optional[Decimal] = Field(None, description="Best ask price")
    open_price: Optional[Decimal] = Field(
        None, description="Opening price for the period"
    )
    high_price: Optional[Decimal] = Field(
        None, description="Highest price for the period"
    )
    low_price: Optional[Decimal] = Field(
        None, description="Lowest price for the period"
    )
    close_price: Optional[Decimal] = Field(
        None, description="Closing price for the period"
    )

    @validator(
        "price",
        "volume",
        "bid",
        "ask",
        "open_price",
        "high_price",
        "low_price",
        "close_price",
    )
    def validate_positive_values(cls, v):
        if v is not None and v < 0:
            raise ValueError("Price and volume values must be non-negative")
        return v


class SignalType(Enum):
    """Trading signal types."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


class SignalEvent(BaseEvent):
    """
    Trading signal event generated by strategies.

    Contains the trading decision and associated confidence level
    for strategy execution.
    """

    event_type: Literal[EventType.SIGNAL] = Field(default=EventType.SIGNAL)
    symbol: str = Field(..., description="Trading symbol")
    signal_type: SignalType = Field(..., description="Type of trading signal")
    confidence: float = Field(
        ..., ge=0.0, le=1.0, description="Signal confidence (0-1)"
    )
    entry_price: Optional[Decimal] = Field(None, description="Suggested entry price")
    stop_loss: Optional[Decimal] = Field(None, description="Stop loss price")
    take_profit: Optional[Decimal] = Field(None, description="Take profit price")
    quantity: Optional[Decimal] = Field(None, description="Suggested position size")
    strategy_name: str = Field(
        ..., description="Name of strategy that generated signal"
    )
    reasoning: Optional[str] = Field(None, description="Strategy reasoning for signal")


class OrderSide(Enum):
    """Order side enumeration."""

    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """Order type enumeration."""

    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderStatus(Enum):
    """Order status enumeration."""

    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class OrderEvent(BaseEvent):
    """
    Order event for trade execution and order management.

    Tracks order lifecycle from creation through execution
    with complete audit trail.
    """

    event_type: Literal[EventType.ORDER] = Field(default=EventType.ORDER)
    order_id: Optional[str] = Field(None, description="Exchange order ID")
    client_order_id: str = Field(..., description="Client-side order ID")
    symbol: str = Field(..., description="Trading symbol")
    side: OrderSide = Field(..., description="Order side (buy/sell)")
    order_type: OrderType = Field(..., description="Order type")
    quantity: Decimal = Field(..., gt=0, description="Order quantity")
    price: Optional[Decimal] = Field(None, description="Order price (for limit orders)")
    stop_price: Optional[Decimal] = Field(
        None, description="Stop price (for stop orders)"
    )
    status: OrderStatus = Field(
        default=OrderStatus.PENDING, description="Current order status"
    )
    filled_quantity: Decimal = Field(
        default=Decimal("0"), description="Filled quantity"
    )
    average_price: Optional[Decimal] = Field(None, description="Average fill price")
    commission: Decimal = Field(default=Decimal("0"), description="Trading commission")
    commission_asset: Optional[str] = Field(None, description="Commission currency")

    @validator("quantity", "filled_quantity", "commission")
    def validate_non_negative(cls, v):
        if v < 0:
            raise ValueError("Quantities and commission must be non-negative")
        return v


class RiskEventType(Enum):
    """Risk event types."""

    POSITION_LIMIT = "position_limit"
    DRAWDOWN_LIMIT = "drawdown_limit"
    EXPOSURE_LIMIT = "exposure_limit"
    MARGIN_CALL = "margin_call"
    STOP_LOSS_HIT = "stop_loss_hit"
    RISK_CHECK_FAILED = "risk_check_failed"


class RiskSeverity(Enum):
    """Risk severity levels."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


class RiskEvent(BaseEvent):
    """
    Risk management event for monitoring and control.

    Handles risk limit violations, margin requirements,
    and other risk-related system events.
    """

    event_type: Literal[EventType.RISK] = Field(default=EventType.RISK)
    risk_type: RiskEventType = Field(..., description="Type of risk event")
    severity: RiskSeverity = Field(..., description="Risk severity level")
    symbol: Optional[str] = Field(None, description="Affected trading symbol")
    current_value: Union[Decimal, float] = Field(
        ..., description="Current risk metric value"
    )
    limit_value: Union[Decimal, float] = Field(..., description="Risk limit threshold")
    description: str = Field(..., description="Human-readable risk description")
    action_required: bool = Field(
        default=False, description="Whether immediate action is required"
    )
    suggested_action: Optional[str] = Field(
        None, description="Suggested risk mitigation action"
    )


# Event type mapping for deserialization
EVENT_TYPE_MAPPING = {
    EventType.MARKET_DATA: MarketDataEvent,
    EventType.SIGNAL: SignalEvent,
    EventType.ORDER: OrderEvent,
    EventType.RISK: RiskEvent,
}


def create_event_from_dict(event_data: Dict[str, Any]) -> BaseEvent:
    """
    Create an event instance from dictionary data.

    Args:
        event_data: Dictionary containing event data

    Returns:
        Appropriate event instance based on event_type

    Raises:
        ValueError: If event_type is unknown or data is invalid
    """
    try:
        event_type = EventType(event_data.get("event_type"))
        event_class = EVENT_TYPE_MAPPING[event_type]
        return event_class(**event_data)
    except (ValueError, KeyError) as e:
        raise ValueError(f"Invalid event data: {e}") from e


def serialize_event(event: BaseEvent) -> Dict[str, Any]:
    """
    Serialize an event to dictionary format.

    Args:
        event: Event instance to serialize

    Returns:
        Dictionary representation of the event
    """
    return event.dict()
