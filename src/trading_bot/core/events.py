"""
Event types and models for the trading bot's event-driven architecture.

This module defines all event types used throughout the system using
pydantic for validation and serialization/deserialization.
"""

from abc import ABC
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, Literal, Optional, Union
from uuid import UUID, uuid4

import pandas as pd
from pydantic import BaseModel, Field, validator


class EventType(Enum):
    """Enumeration of all event types in the system."""

    MARKET_DATA = "market_data"
    SIGNAL = "signal"
    ORDER = "order"
    RISK = "risk"
    POSITION = "position"
    TAKE_PROFIT = "take_profit"
    TRAILING_STOP = "trailing_stop"
    SLIPPAGE = "slippage"
    CANDLE_CLOSED = "candle_closed"
    RISK_APPROVED_ORDER = "risk_approved_order"


class EventPriority(Enum):
    """Event priority levels for processing order."""

    LOW = 1
    NORMAL = 2
    HIGH = 3
    CRITICAL = 4


class BaseEvent(BaseModel, ABC):
    """
    Base class for all events in the trading bot system.

    Provides common event metadata including timestamps, priority,
    and unique identification.
    """

    event_id: UUID = Field(default_factory=uuid4, description="Unique event identifier")
    event_type: EventType = Field(..., description="Type of event")
    timestamp: datetime = Field(
        default_factory=datetime.utcnow, description="Event creation timestamp"
    )
    priority: EventPriority = Field(
        default=EventPriority.NORMAL, description="Event processing priority"
    )
    source: str = Field(..., description="Component that generated this event")
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional event metadata"
    )

    class Config:
        json_encoders = {
            datetime: lambda dt: dt.isoformat(),
            Decimal: lambda d: str(d),
            UUID: lambda u: str(u),
            pd.DataFrame: lambda df: df.to_dict(orient="records"),
        }


class MarketDataEvent(BaseEvent):
    """
    Market data event containing price and volume information.

    Used for real-time and historical market data distribution
    throughout the trading system.
    """

    event_type: Literal[EventType.MARKET_DATA] = Field(default=EventType.MARKET_DATA)
    symbol: str = Field(..., description="Trading symbol (e.g., BTCUSDT)")
    price: Decimal = Field(..., description="Current price")
    volume: Decimal = Field(..., description="Volume in base currency")
    bid: Optional[Decimal] = Field(None, description="Best bid price")
    ask: Optional[Decimal] = Field(None, description="Best ask price")
    open_price: Optional[Decimal] = Field(
        None, description="Opening price for the period"
    )
    high_price: Optional[Decimal] = Field(
        None, description="Highest price for the period"
    )
    low_price: Optional[Decimal] = Field(
        None, description="Lowest price for the period"
    )
    close_price: Optional[Decimal] = Field(
        None, description="Closing price for the period"
    )

    @validator(
        "price",
        "volume",
        "bid",
        "ask",
        "open_price",
        "high_price",
        "low_price",
        "close_price",
    )
    def validate_positive_values(cls, v):
        if v is not None and v < 0:
            raise ValueError("Price and volume values must be non-negative")
        return v


class SignalType(Enum):
    """Trading signal types."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    CLOSE_LONG = "close_long"
    CLOSE_SHORT = "close_short"


class SignalEvent(BaseEvent):
    """
    Trading signal event generated by strategies.

    Contains the trading decision and associated confidence level
    for strategy execution.
    """

    event_type: Literal[EventType.SIGNAL] = Field(default=EventType.SIGNAL)
    symbol: str = Field(..., description="Trading symbol")
    signal_type: SignalType = Field(..., description="Type of trading signal")
    confidence: float = Field(
        ..., ge=0.0, le=1.0, description="Signal confidence (0-1)"
    )
    entry_price: Optional[Decimal] = Field(None, description="Suggested entry price")
    stop_loss: Optional[Decimal] = Field(None, description="Stop loss price")
    take_profit: Optional[Decimal] = Field(None, description="Take profit price")
    quantity: Optional[Decimal] = Field(None, description="Suggested position size")
    strategy_name: str = Field(
        ..., description="Name of strategy that generated signal"
    )
    reasoning: Optional[str] = Field(None, description="Strategy reasoning for signal")


class OrderSide(Enum):
    """Order side enumeration."""

    BUY = "buy"
    SELL = "sell"


class OrderType(Enum):
    """Order type enumeration."""

    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class OrderStatus(Enum):
    """Order status enumeration."""

    PENDING = "pending"
    SUBMITTED = "submitted"
    PARTIALLY_FILLED = "partially_filled"
    FILLED = "filled"
    CANCELLED = "cancelled"
    REJECTED = "rejected"


class OrderEvent(BaseEvent):
    """
    Order event for trade execution and order management.

    Tracks order lifecycle from creation through execution
    with complete audit trail.
    """

    event_type: Literal[EventType.ORDER] = Field(default=EventType.ORDER)
    order_id: Optional[str] = Field(None, description="Exchange order ID")
    client_order_id: str = Field(..., description="Client-side order ID")
    symbol: str = Field(..., description="Trading symbol")
    side: OrderSide = Field(..., description="Order side (buy/sell)")
    order_type: OrderType = Field(..., description="Order type")
    quantity: Decimal = Field(..., gt=0, description="Order quantity")
    price: Optional[Decimal] = Field(None, description="Order price (for limit orders)")
    stop_price: Optional[Decimal] = Field(
        None, description="Stop price (for stop orders)"
    )
    status: OrderStatus = Field(
        default=OrderStatus.PENDING, description="Current order status"
    )
    filled_quantity: Decimal = Field(
        default=Decimal("0"), description="Filled quantity"
    )
    average_price: Optional[Decimal] = Field(None, description="Average fill price")
    commission: Decimal = Field(default=Decimal("0"), description="Trading commission")
    commission_asset: Optional[str] = Field(None, description="Commission currency")

    @validator("quantity", "filled_quantity", "commission")
    def validate_non_negative(cls, v):
        if v < 0:
            raise ValueError("Quantities and commission must be non-negative")
        return v


class RiskEventType(Enum):
    """Risk event types."""

    POSITION_LIMIT = "position_limit"
    DRAWDOWN_LIMIT = "drawdown_limit"
    EXPOSURE_LIMIT = "exposure_limit"
    MARGIN_CALL = "margin_call"
    STOP_LOSS_HIT = "stop_loss_hit"
    RISK_CHECK_FAILED = "risk_check_failed"


class RiskSeverity(Enum):
    """Risk severity levels."""

    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"
    EMERGENCY = "emergency"


class RiskEvent(BaseEvent):
    """
    Risk management event for monitoring and control.

    Handles risk limit violations, margin requirements,
    and other risk-related system events.
    """

    event_type: Literal[EventType.RISK] = Field(default=EventType.RISK)
    risk_type: RiskEventType = Field(..., description="Type of risk event")
    severity: RiskSeverity = Field(..., description="Risk severity level")
    symbol: Optional[str] = Field(None, description="Affected trading symbol")
    current_value: Union[Decimal, float] = Field(
        ..., description="Current risk metric value"
    )
    limit_value: Union[Decimal, float] = Field(..., description="Risk limit threshold")
    description: str = Field(..., description="Human-readable risk description")
    action_required: bool = Field(
        default=False, description="Whether immediate action is required"
    )
    suggested_action: Optional[str] = Field(
        None, description="Suggested risk mitigation action"
    )


class PositionStatus(Enum):
    """Position status enumeration."""

    OPENING = "opening"
    OPEN = "open"
    PARTIAL_CLOSE = "partial_close"
    CLOSING = "closing"
    CLOSED = "closed"


class PositionSide(Enum):
    """Position side enumeration."""

    LONG = "long"
    SHORT = "short"


class PositionEvent(BaseEvent):
    """
    Position event for tracking position lifecycle and P&L updates.

    Handles position state changes, size modifications, and real-time
    profit/loss calculations for active trading positions.
    """

    event_type: Literal[EventType.POSITION] = Field(default=EventType.POSITION)
    position_id: str = Field(..., description="Unique position identifier")
    symbol: str = Field(..., description="Trading symbol")
    side: PositionSide = Field(..., description="Position side (long/short)")
    status: PositionStatus = Field(..., description="Current position status")
    size: Decimal = Field(..., description="Position size")
    entry_price: Decimal = Field(..., description="Average entry price")
    current_price: Optional[Decimal] = Field(None, description="Current market price")
    unrealized_pnl: Optional[Decimal] = Field(None, description="Unrealized P&L")
    realized_pnl: Decimal = Field(default=Decimal("0"), description="Realized P&L")
    stop_loss: Optional[Decimal] = Field(None, description="Stop loss price")
    take_profit: Optional[Decimal] = Field(None, description="Take profit price")
    risk_reward_ratio: Optional[float] = Field(None, description="Current RR ratio")

    @validator("size", "entry_price")
    def validate_positive_values(cls, v):
        if v <= 0:
            raise ValueError("Size and entry price must be positive")
        return v


class TakeProfitType(Enum):
    """Take profit trigger types."""

    PARTIAL_1_1_RR = "partial_1_1_rr"  # 50% at 1:1 RR
    FULL_1_2_RR = "full_1_2_rr"  # Remaining at 1:2 RR
    MANUAL = "manual"  # Manual trigger


class TakeProfitEvent(BaseEvent):
    """
    Take profit event for partial and full profit taking triggers.

    Manages the 1:1 RR 50% profit taking and 1:2 RR full exit logic
    for systematic profit optimization.
    """

    event_type: Literal[EventType.TAKE_PROFIT] = Field(default=EventType.TAKE_PROFIT)
    position_id: str = Field(..., description="Related position identifier")
    symbol: str = Field(..., description="Trading symbol")
    trigger_type: TakeProfitType = Field(..., description="Type of profit taking")
    trigger_price: Decimal = Field(
        ..., description="Price that triggered profit taking"
    )
    target_quantity: Decimal = Field(..., description="Quantity to close")
    current_rr_ratio: float = Field(..., description="Current risk-reward ratio")
    expected_profit: Decimal = Field(..., description="Expected profit amount")


class TrailingStopEvent(BaseEvent):
    """
    Trailing stop event for dynamic stop loss adjustments.

    Manages trailing stop logic to protect profits while allowing
    for continued upside participation.
    """

    event_type: Literal[EventType.TRAILING_STOP] = Field(
        default=EventType.TRAILING_STOP
    )
    position_id: str = Field(..., description="Related position identifier")
    symbol: str = Field(..., description="Trading symbol")
    new_stop_price: Decimal = Field(..., description="New trailing stop price")
    previous_stop_price: Optional[Decimal] = Field(
        None, description="Previous stop price"
    )
    current_price: Decimal = Field(..., description="Current market price")
    trail_distance: Decimal = Field(..., description="Trailing distance")
    is_active: bool = Field(default=True, description="Whether trailing is active")


class SlippageEvent(BaseEvent):
    """
    Slippage event for monitoring execution price differences.

    Tracks differences between expected and actual execution prices
    for order execution quality monitoring and limits.
    """

    event_type: Literal[EventType.SLIPPAGE] = Field(default=EventType.SLIPPAGE)
    order_id: str = Field(..., description="Related order identifier")
    symbol: str = Field(..., description="Trading symbol")
    expected_price: Decimal = Field(..., description="Expected execution price")
    actual_price: Decimal = Field(..., description="Actual execution price")
    slippage_amount: Decimal = Field(..., description="Slippage amount")
    slippage_percentage: float = Field(..., description="Slippage as percentage")
    quantity: Decimal = Field(..., description="Order quantity")
    slippage_cost: Decimal = Field(..., description="Cost of slippage")
    is_limit_exceeded: bool = Field(
        default=False, description="Whether slippage limit exceeded"
    )


# Event type mapping for deserialization
class CandleClosedEvent(BaseEvent):
    """
    Candle closed event containing OHLCV DataFrame for technical analysis.

    Emitted when a candle completes for various timeframes (5m, 15m, 4h, 1d),
    providing complete OHLCV data for strategy analysis and signal generation.
    """

    event_type: Literal[EventType.CANDLE_CLOSED] = Field(
        default=EventType.CANDLE_CLOSED
    )
    symbol: str = Field(..., description="Trading symbol (e.g., BTCUSDT)")
    interval: str = Field(..., description="Timeframe interval (5m, 15m, 4h, 1d)")
    df: pd.DataFrame = Field(..., description="OHLCV DataFrame with historical data")
    timestamp: datetime = Field(
        default_factory=datetime.utcnow, description="Candle close timestamp"
    )
    priority: EventPriority = Field(
        default=EventPriority.HIGH, description="High priority for immediate processing"
    )

    @validator("interval")
    def validate_interval(cls, v):
        valid_intervals = [
            "1m",
            "3m",
            "5m",
            "15m",
            "30m",
            "1h",
            "2h",
            "4h",
            "6h",
            "8h",
            "12h",
            "1d",
            "3d",
            "1w",
        ]
        if v not in valid_intervals:
            raise ValueError(f"Invalid interval: {v}. Must be one of {valid_intervals}")
        return v

    class Config:
        arbitrary_types_allowed = True  # Allow pandas DataFrame


class RiskApprovedOrderEvent(BaseEvent):
    """
    Risk-approved order event after risk management validation.

    Emitted when a trading signal passes risk checks and is approved
    for execution with potentially adjusted quantity and risk parameters.
    """

    event_type: Literal[EventType.RISK_APPROVED_ORDER] = Field(
        default=EventType.RISK_APPROVED_ORDER
    )
    signal: SignalEvent = Field(
        ..., description="Original trading signal that was approved"
    )
    approved_quantity: Decimal = Field(
        ..., gt=0, description="Risk-approved quantity for execution"
    )
    risk_params: Dict[str, Any] = Field(
        ...,
        description="Risk parameters used for approval (max_position_size, stop_loss, etc.)",
    )
    priority: EventPriority = Field(
        default=EventPriority.NORMAL, description="Normal priority for order execution"
    )

    @validator("approved_quantity")
    def validate_approved_quantity(cls, v):
        if v <= 0:
            raise ValueError("Approved quantity must be positive")
        return v


EVENT_TYPE_MAPPING = {
    EventType.MARKET_DATA: MarketDataEvent,
    EventType.SIGNAL: SignalEvent,
    EventType.ORDER: OrderEvent,
    EventType.RISK: RiskEvent,
    EventType.POSITION: PositionEvent,
    EventType.TAKE_PROFIT: TakeProfitEvent,
    EventType.TRAILING_STOP: TrailingStopEvent,
    EventType.SLIPPAGE: SlippageEvent,
    EventType.CANDLE_CLOSED: CandleClosedEvent,
    EventType.RISK_APPROVED_ORDER: RiskApprovedOrderEvent,
}


def create_event_from_dict(event_data: Dict[str, Any]) -> BaseEvent:
    """
    Create an event instance from dictionary data.

    Args:
        event_data: Dictionary containing event data

    Returns:
        Appropriate event instance based on event_type

    Raises:
        ValueError: If event_type is unknown or data is invalid
    """
    try:
        event_type = EventType(event_data.get("event_type"))
        event_class = EVENT_TYPE_MAPPING[event_type]
        return event_class(**event_data)
    except (ValueError, KeyError) as e:
        raise ValueError(f"Invalid event data: {e}") from e


def serialize_event(event: BaseEvent) -> Dict[str, Any]:
    """
    Serialize an event to dictionary format.

    Args:
        event: Event instance to serialize

    Returns:
        Dictionary representation of the event
    """
    return event.dict()
